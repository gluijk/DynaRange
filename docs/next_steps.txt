TAREAS PENDIENTES, ABORDAR EN ESTE ORDEN:

1:	NORMALIZACIÓN A CUALQUIER RESOLUCIÓN PEDIDA (POR DEFECTO 8Mpx)

	--drnormalization-mpx -m <float>
	Definition: number of Mpx for DR normalization (default=8Mpx)
	Explanation: in order to properly and fairly compare different resolution cameras, the SNR values need to be normalized to a given output resolution before calculating the DR. This means DR figures will vary according to this resolution normalization, obtaining higher values the lower the number of Mpx specified
	Usage: by default a 8Mpx based DR is calculated. If no normalization is wanted (per-pixel DR) a value of 0 must be set for this parameter
	Examples (first example is default and is equivalent to not specifying the parameter):
	--drnormalization-mpx      (DR normalized to 8Mpx)
	--drnormalization-mpx 21.5 (DR normalized to 21.5Mpx)
	--drnormalization-mpx 0    (no normalization, per-pixel DR)

	Cambios en el código (dynamicrange_V2.R):

	################################
	# RANGO PARAMETERS

	# --drnormalization-mpx -m <float>
	normalize=TRUE
	drnormalization_mpx=8
	camresolution_mpx=nrow(img)*ncol(img)/1e6

	MIN_SNR_dB = -10
	if (normalize) MIN_SNR_dB = MIN_SNR_dB - 20*log10((camresolution_mpx / drnormalization_mpx)^(1/2))
	calc=analyze_patches(imgcrop, NCOLS=11, NROWS=7, SAFE=50, MIN_SNR_dB)  # SAFE=80
	Signal=calc$Signal
	Noise=calc$Noise
	SNR=Signal/Noise
	# SNR normalization to drnormalization_mpx Mpx
	# Linear: SNR_norm = SNR_perpixel * (Mpx / 8)^(1/2)
	# Log:    SNR_norm dB = SNR_perpixel dB + 20 * log10[(Mpx / 8)^(1/2)]
	if (normalize) SNR=SNR * (camresolution_mpx / drnormalization_mpx)^(1/2)

NOTAS SOBRE LA NORMALIZACIÓN:

Verás que al normalizar todas las curvas se desplazan (hacia arriba si normalizamos por menos Mpx de los que tenemos). Eso significa que para determinada normalización podemos quedarnos sin datos suficientes para obtener el RD, porque no quede ningún punto por debajo de la curva.

Esto se arregla haciendo una comprobación potente de si tenemos datos para cada ISO y sino se emita un mensaje de "Warning: insufficient data to calculate DR for 8Mpx normalization at ISO1600" por ejemplo

Hay que aprovechar ahora para meter esas comprobaciones que comentaba. Es decir tanto si se normaliza como si no, para cada curva ISO hay que asegurar que:
* La muestra (parche) de menor relación S/N de esa curva, una vez normalizada (corregida), está por debajo del umbral de dB con el que calculamos el RD
* La muestra (parche) de mayor relación S/N, una vez normalizada (corregida) está por encima del umbral de dB con el que calculamos el RD

En caso contrario para ese ISO no se calcula el RD y el programa emite un mensaje tipo "Warning: insufficient data to calculate 12dB dynamic range at 8Mpx normalization, test chart was subexposed/underexposed".

Lo meto hoy en el código porque es muy importante, no solo para la normalización sino para detectar cartas mal expuestas. Las de Hugo estaban muy bien expuestas pero aquí es fácil que un usuario meta la pata.
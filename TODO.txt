Varios comentarios:

TODO 1: CÁLCULO DE BLACK/SAT DESDE FICHEROS RAW -> (HECHO)
    
    Entiendo que de momento solo funciona con valores black/sat pasados por el usuario.
Faltaría añadir la posibilidad de obtenerlos de fichero RAW. Para black sería la media de todos
los píxeles del RAW darkframe. Para sat el cuantil 5% (o incluso 1%) del RAW saturado obtenido
con la función simplona que te pasé. 

        He simplificado la función del cálculo del percentil 5% parametrizándola
         (perc=0.5 es la mediana de toda la vida, perc=0.05 es el percentil 5%, etc...):

        cppFunction('
                    double quantilecpp(Rcpp::NumericVector xx, double perc) {
                    Rcpp::NumericVector x = Rcpp::clone(xx);
                    std::size_t n = x.size() * perc;
                    std::nth_element(x.begin(), x.begin() + n, x.end());
                    return x[n]; 
                    }
                    ')

        set.seed(10)
        x=rnorm(24000000)  # sensor de 24Mpx

        median1=quantile(x, probs=0.05) |> as.numeric()
        median2=quantilecpp(x, 0.05)


TODO 2: DISEÑO CARTA MAGENTA Y CORRECCIÓN GEOMÉTRICA
    
    La corrección geométrica está hard coded para las tomas de la Olympus de Hugo. 
Aquí tendremos que hablar sobre un diseño de carta que incluya guías para detectar sus 4 esquinas.
Creo que con 4 círculos blancos + detección del valor máximo en la zona bastará.
No hemos hablado de la carta, si usamos la de Bill Claff o nos inventamos una.
Sea como sea la carta de Bill Claff no tiene testigos en las 4 esquinas para poder
corregir los errores del usuario en la toma y hacer la corrección geométrica. 
La que viste en el código está hard coded para los RAW de Hugo, pero claro no vale de forma general
La carta de Bill, bien generada, y con 4 círculos blancos en las esquinas, 
debería ser fácil de detectar sus esquinas. Yo escribiría la función para detectar esos 4 puntos


TODO 3: CURVAS DE APROXIMACIÓN vs INTERPOLACIÓN

(Los splines son de verdad, mejor usar *ajuste por mínimos cuadrados* "least-squares fit" )

    Tus splines son splines de verdad? es decir, pasan por los puntos calculados o los aproximan?
Lo comento porque aunque mi código R las llama splines, que son curvas de interpolación, 
en realidad lo que acabo usando son curvas de aproximación, es decir curvas que no pasan exactamente
por los puntos sino que los aproximan suavemente. 
Esto es importante para que las desviaciones de las medidas no introduzcan error.


TODO 4: ORDENACIÓN FICHEROS RAW POR EXPOSICIÓN -> (HECHO)

    Sobre los ficheros RAW suministrados por el usuario, en realidad no necesitamos ni saber
 el ISO de cada uno ni obligar al usuario a renombrarlos u ordenarlos. 
 Con sus niveles RAW medios ya los podemos ordenar de menos a más exposición 
 (lo que equivale de menos a más ISO). Sería bueno que en la salida aparezcan ordenados 
 (salvo casos raros, los propios nombres de los RAW ya deberían implicar una ordenación, 
 pero igual un usuario empezó por el ISO mayor o repitió tomas)


TODO 6: INTERNACIONALIZACIÓN -> (HECHO)

    i18n -> Internacionalización -> Que el programa se pueda usar en varios idiomas disponibles.


TODO 5: NORMALIZACIÓN A CUALQUIER RESOLUCIÓN PEDIDA (POR DEFECTO 8Mpx)

   Código para normalización del RD para cierta cantidad de Mpx, que sería la usable para
comparar cámaras de forma justa. El cálculo a nivel de píxel actual es injusto para las cámaras
con muchos Mpx. Te pasaré la formula, es sencilla.


TODO 8: CÁLCULO ESQUINAS CARTA MAGENTA PARA CORRECCIÓN GEOMÉTRICA

    Código para cálculo esquinas carta (max del canal G del RAW en cada cuadrante)


TODO 9: VALORES DE BLACK/SAT POR DEFECTO: APROXIMACIÓN DESDE LAS CAPTURAS DE LA CARTA A ISO BASE

    Código para obtención valores por defecto BLACK y SAT si el usuario no los aporta 
    BLACK=mínima potencia de 2 con datos en la toma ISO mínimo. P.ej. si el valor RAW más bajo es 900 -> BLACK=1023
    SAT=fondo escala bits toma ISO máximo. P.ej. si el valor RAW máximo es 13000 -> SAT=16383
